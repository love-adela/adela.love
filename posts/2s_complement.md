---
title: '논리회로에서 음수 표현하기'
subtitle: 'MSB 값에 따라 양수와 음수를 표현해보자'
date: '2020-04-27'
---

논리회로에서 음수를 표현하는 방법은 여러가지가 있습니다. 이번 포스팅에서는 그중에서 0 또는 1인 MSB의 값에 따라 양수와 음수를 표현하는 방법을 알아보겠습니다. 각각의 표현 방식은 아래와 같은 장단점이 있는데, 이중에서 가장 많이 쓰이는 부호 표현 방식은 2의 보수(two's complement)입니다. 2의 보수를 사용하면 간단하게 회로를 구성할 수 있기 때문에 비용을 줄일 수 있습니다.

## 1. 부호 절대값 (Sign-Magnitude)

### 1.1 구성

- 부호 : MSB(Most Significant Bit)
  - 0이면 양수, 1이면 음수
- 절대값 : 나머지 비트

### 1.2 문제점

- `0`이 `+0`과 `-0` 두 개의 부호를 갖게됩니다. `+0`과 `-0`이 모두 `0`으로 인식하도록 별도의 연산을 수행해야 합니다.
- 덧셈을 구현할 때 : 부호와 절대값을 따로 분리해서 계산해야 합니다.
    - 음수를 더하면 음의 부호가 붙지만 값은 절대값끼리의 합이 됩니다.
- 뺄셈을 구현할 때 : 절대값이 큰 수에서 작은 수를 빼야 합니다. 그 반대의 경우에는 순서를 바꿔서 구현해야 하지만, 이를 회로로 만들기가 어렵습니다.
    - 음수를 더하는 방식으로는 뺄셈이 구현되지 않습니다. 뺄셈기를 따로 구현해야 합니다.
- `<` , `>` , `<=` , `>=` 등의 비교연산을 수행할 때 모순이 생깁니다.

## 2. 1의 보수 (1's Complement)

### 2.1 특징

- 부호 절대값 방식에서 음수일 때의 값의 순서를 반대로 두었습니다.
- 양수 값을 나타내는 비트를 하나씩 반전시키면 음수 값이 표현됩니다. 여전히 0이면 양수, 1이면 음수가 됩니다.
- 부호 절대값 방식처럼 부호와 절대값을 따로 계산하지 않고, 음수를 더함으로써 뺄셈을 할 수 있게 됩니다. 또한 덧셈, 뺄셈 모두 간편해집니다.
- 캐리가 발생하면 LSB(Least Significant Bit)에 1을 더해줘야 합니다.
- 부호 절대값 방식에서 발생했던 음수의 비교연산 모순이 일어나지 않습니다.

### 2.2 문제점

- `0`이 `+0`과 `-0` 두 개의 부호를 갖게됩니다. 둘 다 0으로 인식하도록 별도의 연산을 수행해야 합니다.
  - 4bit 일 때, 0000과 1111 모두 0으로 처리해야 합니다.
  - 캐리가 발생되었는지 확인하기 위해 LSB에 1을 더해주는 회로를 따로 구성해야 합니다.

## 3. 2의 보수 (2's Complement)

### 3.1 특징

- `-0` 대신 -8을 도입합니다. 따라서 1의 보수에서 생겼던 `-0` 이 사라지고 캐리를 따로 처리해야 하지 않아도 됩니다.
  - 수학적인 일관성을 보장합니다.
- 덧셈, 뺄셈 모두 덧셈기로만 연산이 가능해 회로가 간단해집니다.
  - 캐리를 따로 처리하지 않습니다.
- 부호를 신경쓰지 않고 곱셈 연산을 할 수 있습니다.

### 3.2 부호를 표시하는 방법

- MSB가 0이면 양수, 1이면 음수
- 부호를 바꾸려면 비트를 하나씩 반전해서 LSB에 1을 더합니다.

### 3.3 Modulo 연산에 따른 순환군

예를 들어 4비트 정수는 `A={0, 1, 2,3,4,5,6,7,8,9,10,11,12,13,14,15}`가 있는 `mod 2^4`를 한 집합으로 볼 수 있습니다.

- 정수 x, y에 대해 성립하던 덧셈/뺄셈에 관련된 수학적 성질이 `x mod 2^4`, `y mod 2^4`에 대해서도 성립합니다.
- `x= 24`, `y=20`, `x-y=4`는 4비트 정수에서도 성립합니다.

      1. 24 mod 2^4 = 8
      2. 20 mod 2^4 = 4

이렇게 x, y에 대한 modulo 값으로 연산하면 연산에 대한 결과값을 집합 A 안에서 찾을 수 있게 됩니다.

### 3.4 한계

순환군에 의해 나눗셈을 정의하면 원치 않는 값이 나오기도 합니다. 오버플로우가 발생하기 때문에 나눗셈의 경우에는 예외처리를 합니다.

*참고: 오버플로우(overflow) : 모듈로를 취하지 않았을 때 값을 찾을 수 없는 현상*
